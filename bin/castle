#!/usr/bin/env node

const {transpile, copyFile, info, warn, error} = require('../utils');
const colors = require('colors');
const {exec, execSync} = require('child_process');
const glob = require('glob');
const fs = require('node-fs');
const path = require('path');
const version = require('../package').version;

const yargs = require('yargs')
    .usage(`Castle CLI  ${version} \n\nUsage: $0 [<command>] [options]`)
    .version(() => version)
    .command('new', 'Create new Castle project')
    .command('build', 'Compile Castle to C, and the build C project with make')
    .command('build-castle', 'Compile Castle to C')
    .command('build-target', 'Compile C sources')
    .command('help', 'Show this screen')
    .options({
        's': {
            alias: 'src-dir',
            demand: false,
            describe: 'source files directory',
            type: 'string',
        },
        't': {
            alias: 'target-dir',
            demand: false,
            describe: 'target directory',
            type: 'string',
        },
        'b': {
            alias: 'build-dir',
            demand: false,
            describe: 'build directory',
            type: 'string',
        },
        'r': {
            alias: 'root-dir',
            demand: false,
            describe: 'project root directory',
            type: 'string',
        },
        'm': {
            alias: 'mode',
            demand: false,
            describe: 'compilation mode (debug or release)',
            type: 'string',
        },
        'c': {
            alias: 'c-build-tool',
            demand: false,
            describe: 'what to use for compiling C sources',
            type: 'string',
            choices: ['make'],
        },
        'n': {
            alias: 'no-syntax',
            demand: false,
            describe: 'turns off sweet.js macros',
            type: 'boolean',
        },
        'B': {
            alias: 'build-script',
            demand: false,
            describe: 'use build script',
            type: 'string',
        }
    });

yargs.help();

const argv = yargs.argv;
const command = argv._[0] || 'help';

const options = {
    s: argv.s || 'src',
    t: argv.t || 'target',
    b: argv.b || 'build',
    m: argv.m || 'debug',
    c: argv.c || 'make',
    n: argv.n || false,
    B: argv.B || null,
    r: argv.r || process.cwd(),
};

const makefile = `
.PHONY : all clean

all: $(patsubst src/%.c,bin/%,$(wildcard src/*.c))

bin/%.o: src/%.c
	clang -g -Wall -Werror -std=c11 -c $? -o $@

bin/%:  bin/%.o
	clang -g $? -o $@ -L/usr/lib/x86_64-linux-gnu -lm

clean:
	find bin/ -type f -exec rm {} \;
`;

const gitignore = `
# Castle build dirs
build/
target/

# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage

# nyc test coverage
.nyc_output

# Grunt intermediate storage (http://gruntjs.com/creating-plugins#storing-task-files)
.grunt

# Bower dependency directory (https://bower.io/)
bower_components

# node-waf configuration
.lock-wscript

# Compiled binary addons (http://nodejs.org/api/addons.html)
build/Release

# Dependency directories
node_modules/
jspm_packages/

# Typescript v1 declaration files
typings/

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variables file
.env
`;

switch (command) {
    case 'help':
        yargs.showHelp();
        break;
    case 'new':
        createProject();
        break;
    case 'build':
        buildCastle();
        buildTarget();
        break;
    case 'build-castle':
        buildCastle();
        break;
    case 'build-target':
        buildTarget();
        break;
    default:
        yargs.showHelp();
        error(`Unknown command '${command}'`);
        process.exit(1);
}

function createProject() {
    console.log(``);
    if (argv._.length < 2) {
        error('Project name is not specified');
    }
    const projectName = argv._[1];

    if (fs.existsSync(projectName)) {
        error(`Directory ${projectName} already exists`);
    }

    info('Creating project directory');
    fs.mkdirSync(projectName);

    const json = JSON.stringify({
        "name": projectName,
        "version": "0.1.0",
        "scripts": {
            "build": "castle build",
        }
    });

    info('Creating \'package.json\' file');
    fs.writeFileSync(path.join(projectName, 'package.json'), json);

    info('Creating \'.gitignore\' file');
    fs.writeFileSync(path.join(projectName, '.gitignore'), gitignore);

    if (options.n) {
        info('Installing \'castle-core\' and \'castle-cli\' npm packages');
        execSync(
            `cd ${projectName} && npm i --save-dev castle-core@^0.2.0`,
            {stdio:[0,1,2]}
        );
    } else {
        info('Installing \'castle-core\', \'castle-syntax\' and \'castle-cli\' npm packages');
        execSync(
            `cd ${projectName} && npm i --save-dev castle-core@^0.2.0 castle-syntax@^0.2.0`,
            {stdio:[0,1,2]}
        );
    }
    
    info(`Creating sources directry '${options.s}'`);
    fs.mkdirSync(path.join(projectName, options.s, 'castle'),   0777,   true);
    fs.mkdirSync(path.join(projectName, options.s, 'js'),       0777,   true);
    fs.mkdirSync(path.join(projectName, options.s, 'c'),        0777,   true);
    info(`Creating target directory '${options.t}'`);
    fs.mkdirSync(path.join(projectName, options.t, 'js'),       0777,   true);
    fs.mkdirSync(path.join(projectName, options.t, 'c'),        0777,   true);
    info(`Creating build directory '${options.b}'`);
    fs.mkdirSync(path.join(projectName, options.b, 'src'),      0777,   true);
    fs.mkdirSync(path.join(projectName, options.b, 'bin'),      0777,   true);

    if (options.c === 'make') {
        info('Creating Makefile');
        fs.writeFileSync(path.join(projectName, options.b, 'Makefile'), makefile);
    }
}


function buildCastle() {
    info('Starting project build');
    
    info('Cleaning previous build');
    clearJs();
    clearC();

    if (!options.n) {
        info('Compiling *.cst to *.js');
        expandMacros();
    }

    info('Copying *.c and *.js files');
    copyJsToTarget();
    copyCToTarget();

    info('Generating C sources');
    generateTargetCode();
}

function clearJs() {
    const outDir = path.join(options.r, options.t, 'js');
    execSync(`cd ${outDir} && rm -rf **/*.js`);
    
    const buildDir = path.join(options.r, options.b);
    execSync(`cd ${buildDir} && rm -rf **/*.c`);
}

function clearC() {
    const outDir = path.join(options.r, options.t, 'c');
    execSync(`cd ${outDir} && rm -rf **/*.c`);
}

function expandMacros() {
    const files = glob.sync('**/*', { cwd: path.join(options.r, options.s, 'castle') });
    for (let file of files) {
        const fullName = path.join(options.r, options.s, 'castle', file);
        const outDir = path.join(options.r, options.t, 'js', path.dirname(file))
        const outName = path.join(outDir, path.basename(file, '.cst') + '.js');
        if (!fs.existsSync(outDir)) {
            info(`Creating '${outDir}' directory`);
            fs.mkdirSync(dirname, 0777, true);
        }
        info('Expanding Sweet.js macros');
        execSync(`./node_modules/.bin/sjs ${fullName} -o ${outName}`);
        const ts = fs.readFileSync(outName);
        info('Compiling TypeScript to JavaScript');
        fs.writeFileSync(outName, transpile(ts.toString()));
    }
}

function copyJsToTarget() {
    const files = glob.sync('**/*.js', { cwd: path.join(options.r, options.s, 'js') });
    for (let file of files) {
        const fullName = path.join(options.r, options.s, 'js', file);
        const outDir = path.join(options.r, options.t, 'js', path.dirname(file));
        const outName = path.join(outDir, path.basename(file));
        if (!fs.existsSync(outDir)) {
            info(`Creating '${outDir}' directory`);
            fs.mkdirSync(dirname, 0777, true);
        }
        copyFile(fullName, outName);
    }
}


function copyCToTarget() {
    const files = glob.sync('**/*', { cwd: path.join(options.r, options.s, 'c') });
    for (let file of files) {
        const fullName = path.join(options.r, options.s, 'c', file);
        const outDir = path.join(options.r, options.t, 'c', path.dirname(file));
        const outName = path.join(outDir, path.basename(file));
        if (!fs.existsSync(outDir)) {
            info(`Creating '${outDir}' directory`);
            fs.mkdirSync(dirname, 0777, true);
        }
        copyFile(fullName, outName);
    }
}

function generateTargetCode() {
    const castle = require(path.join(options.r, '/node_modules/castle-core'));
    const files = glob.sync('**/*', { cwd: path.join(options.r, options.t, 'js') });
    for (let file of files) {
        const fullName = path.join(options.r, options.t, 'js', file);
        const outDir = path.join(options.r, options.t, 'c', path.dirname(file));
        const outName = path.join(outDir, path.basename(file, '.js'));
        if (!fs.existsSync(outDir)) {
            info(`Creating '${outDir}' directory`);
            fs.mkdirSync(dirname, 0777, true);
        }
        let m = require(fullName);
        if (m.default !== undefined) m = m.default;
        const out = m.compile(new castle.Context());
        fs.writeFileSync(outName, out);
    }
}

function buildTarget() {
    execSync(`rm -rf ${options.b}/{src,bin}/**/*`);
    const cps = path.join(options.r, options.t, 'c');
    execSync(`find ${cps} -exec cp -r {} ${path.join(options.b, 'src')}/ \\;`)
    info('Compiling C sources');
    execSync(`cd ${options.b} && make`);
}
